import tensorflow as tf
from cnn_model_class_def import CnnModelClass
from foolbox.models import TensorFlowModel
from foolbox.attacks import FGSM
from foolbox.utils import softmax
import numpy as np
import cv2
from cleverhans.model import Model





def craft_fgsm():
    network = CnnModelClass()
    network.yield_dataset()
    data_graph = tf.Graph()
    with data_graph.as_default():
        images = tf.convert_to_tensor(network.converted_train_data[0])
        images = tf.expand_dims(images, 0)
        embedded_mat_piece = tf.nn.embedding_lookup(tf.convert_to_tensor(network.embedding_mat), network.converted_train_data)
        embedded_mat_piece = tf.expand_dims(embedded_mat_piece, 0)
        with tf.Session() as session:
            final_image = session.run(embedded_mat_piece)

    image_tf = tf.convert_to_tensor(final_image, np.float32)
    restore_op = tf.train.import_meta_graph(network.root_dir + '\\' + network.model_name + '.meta')
    main_graph = tf.get_default_graph()

    with main_graph.as_default():
        logits = main_graph.get_collection_ref('scores')[0]

        with tf.Session() as session:
            restore_op.restore(session, network.root_dir + '\\' + network.model_name)
            # session.run(main_graph.get_collection_ref('iter')[0].initializer)
            model = TensorFlowModel(image_tf, logits)
            # print(foolbox.utils.softmax(model.predictions(embedded_mat_piece))[0])


            attack = FGSM(model)
            adversarial = attack(final_image, 1)

#
# class cnn_model_adversarial(Model):
#
#     def __init__(self):
#         super(cnn_model_adversarial, self).__init__(scope='model')
#


class InceptionModel(Model):
  """Model class for CleverHans library."""

  def __init__(self, nb_classes):
    super(InceptionModel, self).__init__(nb_classes=nb_classes,
                                         needs_dummy_fprop=True)
    self.built = False

  def __call__(self, x_input, return_logits=False):
    """Constructs model and return probabilities for given input."""
    reuse = True if self.built else None
    with slim.arg_scope(inception.inception_v3_arg_scope()):
      # Inception preprocessing uses [-1, 1]-scaled input.
      x_input = x_input * 2.0 - 1.0
      _, end_points = inception.inception_v3(
          x_input, num_classes=self.nb_classes, is_training=False,
          reuse=reuse)
    self.built = True
    self.logits = end_points['Logits']
    # Strip off the extra reshape op at the output
    self.probs = end_points['Predictions'].op.inputs[0]
    if return_logits:
      return self.logits
    else:
      return self.probs

  def get_logits(self, x_input):
    return self(x_input, return_logits=True)

  def get_probs(self, x_input):
    return self(x_input)





if __name__ == "__main__":
    craft_fgsm()